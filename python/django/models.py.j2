{%- set m = yaml.load('''
name: ModelData
description: ''
key:
  - name
fields:
  name:
''' ) %}

{%- macro render_field(name, props) %}
    {%- set type = props.type or props or 'str' %}
    {%- if props.fk -%}
        models.ForeignKey('{{ props.fk }}'
                          {%- if props.rel %}, related_name='{{ props.rel }}'{% endif -%})
    {%- elif props.oto -%}
        models.ForeignKey('{{ props.oto }}'
                          {%- if props.rel %}, related_name='{{ props.rel }}'{% endif -%})
    {%- elif type == 'str' -%}
        models.CharField(max_length=255, help_text=_("{{ props.help or name.capitalize() }}"))
    {%- elif type == 'int'  -%}
        models.IntegerField(help_text=_("{{ props.help or name.capitalize() }}"))
    {%- elif type == 'bool' -%}
        models.BooleanField(help_text=_("{{ props.help or name.capitalize() }}"))
    {%- endif %}
{%- endmacro %}


{%- macro render_key_types()  %}
{%- for key in m.key -%}
{{ m.fields[key].type or m.fields[key] or 'Text' }}{% if not loop.last %}, {% endif %}
{%- endfor %}
{%- endmacro -%}


# -*- coding: utf-8 -*-
"""{{ m.name }} model."""
{#  #}
{%- if 'natural_key_tuple' in m.modes %}
from collections import namedtuple
{%- endif %}
{%- if 'natural_key_bulk' in m.modes %}
from operator import or_
{%- endif %}

from django.db import models
{%- if 'natural_key_bulk' in m.modes %}
from django.db.models import Q
{%- endif %}
from django.utils.encoding import python_2_unicode_compatible
from django.utils.translation import ugettext_lazy as _
{%- if 'natural_key_bulk' in m.modes %}
from django.utils.six.moves import reduce
{%- endif %}
{%- if 'typing' in m.modes %}

MYPY = False
if MYPY:
    from typing import Dict, Iterable, Text, Tuple
{%- endif %}
{%- if 'natural_key' in m.modes %}


class {{ m.name }}Manager(models.Manager):
    def get_by_natural_key(self, {{ m.key | join(', ') }}):
        {%- if 'typing' in m.modes %}
        # type: ({{ render_key_types() }}) -> {{ m.name }}
        {%- endif %}
        return self.get(
            {% for field in m.key %}{{ field }}={{ field }}, {% endfor %}
        )
    {%- if 'natural_key_bulk' in m.modes %}

    def in_bulk_by_natural_key(
        self,
        natural_keys  # type: Iterable[Tuple[{{ render_key_types() }}]]
    ):  # type: (...) -> Dict[{{ m.name }}.NaturalKey, {{ m.name }}]
        if not natural_keys:
            return {}

        q_expressions = (Q(
            {% for field in m.key %}{{ field }}={{ field }},{% if not loop.last %} {% endif %}{% endfor %}
        ) for {{ m.key | join(', ') }} in natural_keys)

        model_data = self.filter(reduce(or_, q_expressions))
        return {m.natural_key(): m for m in model_data}
    {%- endif %}
{%- endif %}


@python_2_unicode_compatible
class {{ m.name }}(models.Model):
    """{{ m.description }}"""
    {%- for field, descriptor in m.fields.items() %}
    {{ field }} = {{ render_field(field, descriptor) }}
    {%- endfor %}
    {%- if 'natural_key' in m.modes %}

    objects = {{ m.name }}Manager()
    {%- endif %}
    {%- if 'natural_key_tuple' in m.modes %}

    NaturalKey = namedtuple('{{ m.name }}Key', ['{{ m.key | join("', '") }}'])
    {%- endif  %}
    {%- if m.key %}

    class Meta:
        {%- if m.key %}
        unique_together = (
            ('{{ m.key | join("', '") }}',),
        )
        {%- endif %}
    {%- endif %}

    def __str__(self):
        return '<{{ m.name }} {self.pk}>'.format(self=self)
    {%- if 'natural_key' in m.modes  %}

    def natural_key(self):  {#  #}
        {%- if 'typing' in m.modes -%}
        # type: (...) -> {% if 'natural_key_tuple' in m.modes %}{{ m.name }}.NaturalKey{% endif %}
        {%- endif %}
        {%- if 'natural_key_tuple' in m.modes %}
        return self.NaturalKey({% for field in m.key %}self.{{ field }}{% if not loop.last %}, {% endif %}{% endfor %})
        {%- else %}
        return {% for field in m.key %}self.{{ field }}{% if not loop.last %}, {% endif %}{% endfor %}
        {%- endif %}
    {%- endif %}
